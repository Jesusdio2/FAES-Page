<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>WebGL2 Ray Tracing WASD + Calidad dinámica</title>
  <style>
    html, body { margin:0; height:100%; background:#000; }
    canvas { width:100vw; height:100vh; display:block; }
    #hud {
      position:fixed; top:10px; left:10px; color:#0f0; font:12px/1.4 monospace;
      background:rgba(0,0,0,0.4); padding:8px; border:1px solid #0f0;
    }
  </style>
</head>
<body>
  <canvas id="gfx"></canvas>
  <div id="hud">WASD: mover | Espacio: subir | Shift: bajar | FPS: <span id="fps">0</span><br>
  scale:<span id="scale">1.00</span> spp:<span id="spp">4</span> bounces:<span id="bounces">3</span></div>

<script>
/* --------- Declaración temprana --------- */
let quality = { scale: 1.0, spp: 4, bounces: 3 };
let resetAccumulation = 1;

/* --------- Canvas y HUD --------- */
const canvas = document.getElementById("gfx");
const hudFPS = document.getElementById("fps");
const hudScale = document.getElementById("scale");
const hudSPP = document.getElementById("spp");
const hudBounces = document.getElementById("bounces");

const gl = canvas.getContext("webgl2", { antialias: false });
if (!gl) { alert("Tu navegador no soporta WebGL2"); throw new Error("WebGL2 no disponible"); }
const extColorFloat = gl.getExtension("EXT_color_buffer_float");
const extTexFloatLinear = gl.getExtension("OES_texture_float_linear");

/* --------- Resize --------- */
function resize() {
  const w = canvas.clientWidth | 0;
  const h = canvas.clientHeight | 0;
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w; canvas.height = h;
    recreateTargets();
  }
}
window.addEventListener("resize", resize);
resize();

/* --------- Cámara e input --------- */
let camPos = [0, 1.2, 4.0];
let camYaw = 0.0;
let camPitch = 0.0;
let moveSpeed = 2.5;
let keys = new Set();
let mouseDown = false;
let lastMouse = {x:0,y:0};

document.addEventListener("keydown", (e)=> keys.add(e.code));
document.addEventListener("keyup", (e)=> keys.delete(e.code));
canvas.addEventListener("mousedown", (e)=> { mouseDown = true; lastMouse.x=e.clientX; lastMouse.y=e.clientY; });
document.addEventListener("mouseup", ()=> mouseDown=false);
document.addEventListener("mousemove", (e)=>{
  if (!mouseDown) return;
  const dx = e.clientX - lastMouse.x;
  const dy = e.clientY - lastMouse.y;
  lastMouse.x = e.clientX; lastMouse.y = e.clientY;
  const sens = 0.0025;
  camYaw += dx * sens;
  camPitch = Math.max(-1.2, Math.min(1.2, camPitch - dy * sens));
  cameraMoved();
});

/* --------- Calidad dinámica --------- */
const targetFPS = 60;
const targetFrameMs = 1000/targetFPS;
let stableFrames = 0;
let moving = false;
let lastPose = { pos: camPos.slice(), yaw: camYaw, pitch: camPitch };

function poseDelta() {
  const dp = [
    camPos[0]-lastPose.pos[0],
    camPos[1]-lastPose.pos[1],
    camPos[2]-lastPose.pos[2]
  ];
  const ang = Math.abs(camYaw - lastPose.yaw) + Math.abs(camPitch - lastPose.pitch);
  const mag = Math.hypot(dp[0], dp[1], dp[2]) + ang;
  lastPose.pos = camPos.slice();
  lastPose.yaw = camYaw; lastPose.pitch = camPitch;
  return mag;
}
function cameraMoved(){ moving = true; resetAccumulation = 1; }
function updateAdaptive(frameMs) {
  const motion = poseDelta();
  moving = motion > 0.001 || frameMs > targetFrameMs;
  if (moving) {
    quality.scale = Math.max(0.55, quality.scale * 0.92);
    quality.spp = Math.max(1, Math.floor(quality.spp * 0.75));
    quality.bounces = Math.max(2, quality.bounces - 1);
    resetAccumulation = 1;
    stableFrames = 0;
  } else {
    stableFrames++;
    if (stableFrames > 12) {
      quality.scale = Math.min(1.0, quality.scale * 1.04);
      if (quality.spp < 8) quality.spp += 1;
      if (quality.bounces < 4) quality.bounces += 1;
    }
  }
  hudScale.textContent = quality.scale.toFixed(2);
  hudSPP.textContent = String(quality.spp);
  hudBounces.textContent = String(quality.bounces);
}

/* --------- Shaders --------- */
const vsQuad = `#version 300 es
layout(location=0) in vec2 aPos;
layout(location=1) in vec2 aUV;
out vec2 vUV;
void main(){
  vUV = aUV;
  gl_Position = vec4(aPos, 0.0, 1.0);
}
`;

const fsPathTrace = `#version 300 es
precision highp float;
in vec2 vUV;
out vec4 fragColor;

uniform vec3 uCamPos;
uniform vec3 uCamFwd;
uniform vec3 uCamRight;
uniform vec3 uCamUp;

uniform vec2 uResolution;
uniform float uScale;
uniform int uSPP;
uniform int uBounces;
uniform int uResetAccum;
uniform int uFrameIndex;

uniform sampler2D uHistory;

// Escena: 4 esferas (centro.xyz, radio, color.rgb, roughness)
uniform vec4 uSphereCenterRadius[4];
uniform vec4 uSphereColorRough[4];

float rand(vec2 p, float seed){
  return fract(sin(dot(p, vec2(12.9898, 78.233)) + seed) * 43758.5453);
}
vec3 sampleHemisphere(vec3 n, vec2 rnd){
  float phi = 6.2831853 * rnd.x;
  float cosTheta = sqrt(1.0 - rnd.y);
  float sinTheta = sqrt(1.0 - cosTheta*cosTheta);
  vec3 up = abs(n.y) > 0.99 ? vec3(1,0,0) : vec3(0,1,0);
  vec3 t = normalize(cross(up, n));
  vec3 b = cross(n, t);
  return normalize(t*(cos(phi)*sinTheta) + b*(sin(phi)*sinTheta) + n*cosTheta);
}

bool intersectSphere(vec3 ro, vec3 rd, vec4 scR, out float t, out vec3 n){
  vec3 oc = ro - scR.xyz;
  float b = dot(oc, rd);
  float c = dot(oc, oc) - scR.w*scR.w;
  float h = b*b - c;
  if (h < 0.0) { t = -1.0; return false; }
  float tt = -b - sqrt(h);
  if (tt < 0.0001) { t = -1.0; return false; }
  t = tt;
  vec3 p = ro + rd * t;
  n = normalize(p - scR.xyz);
  return true;
}

struct Hit { vec3 p; vec3 n; vec3 color; float rough; bool ok; };

Hit traceScene(vec3 ro, vec3 rd){
  float tMin = 1e9; Hit h; h.ok=false;
  for (int i=0; i<4; ++i){
    float t; vec3 n;
    if (intersectSphere(ro, rd, uSphereCenterRadius[i], t, n)){
      if (t > 0.0 && t < tMin){
        tMin = t; h.ok = true;
        h.p = ro + rd * t;
        h.n = n;
        h.color = uSphereColorRough[i].xyz;
        h.rough = uSphereColorRough[i].w;
      }
    }
  }
  return h;
}

void main(){
  vec2 uv = vUV;
  vec2 ndc = uv*2.0 - 1.0;
  vec3 col = vec3(0.0);
  float seedBase = float(uFrameIndex);

  for (int s=0; s<uSPP; ++s){
    // Jitter aleatorio para antialiasing
    float j1 = rand(uv, seedBase + float(s));
    float j2 = rand(uv + 0.37, seedBase + float(s)*1.3);

    // Dirección primaria de rayo (pinhole camera)
    vec3 dir = normalize(uCamFwd + uCamRight*ndc.x + uCamUp*ndc.y);

    vec3 rayO = uCamPos;
    vec3 rayD = dir;
    vec3 throughput = vec3(1.0);
    vec3 radiance = vec3(0.0);

    for (int b=0; b<uBounces; ++b){
      Hit h = traceScene(rayO, rayD);
      if (!h.ok){
        // Fondo (cielo)
        float t = 0.5*(rayD.y+1.0);
        vec3 sky = mix(vec3(0.6,0.7,1.0), vec3(0.1,0.1,0.12), t);
        radiance += throughput * sky;
        break;
      }
      // Iluminación difusa simple
      float nl = max(dot(h.n, vec3(0,1,0)), 0.0);
      vec3 sky = vec3(0.8,0.85,1.0)*0.1;
      radiance += throughput * (h.color * (0.05 + 0.95*nl) + sky*0.05);

      // Scatter: mezcla reflexión y difusión
      float r1 = rand(uv + vec2(float(b),0.0), seedBase + float(s)*2.1);
      float r2 = rand(uv + vec2(0.0,float(b)), seedBase + float(s)*3.7);
      vec3 hemi = sampleHemisphere(h.n, vec2(r1,r2));
      rayO = h.p + h.n*0.001;
      rayD = normalize(mix(reflect(rayD, h.n), hemi, h.rough));
      throughput *= h.color;
    }
    col += radiance;
  }
  col /= float(uSPP);

  // Acumulación temporal
  if (uResetAccum == 0) {
    vec3 prev = texture(uHistory, uv).rgb;
    col = mix(prev, col, 0.1);
  }

  fragColor = vec4(col, 1.0);
}
