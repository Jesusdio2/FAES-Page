<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>WebGL2 Ray Tracing – Agujero Negro</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: black;
}
canvas {
  width: 100vw;
  height: 100vh;
  display: block;
}
#hud {
  position: fixed;
  top: 10px;
  left: 10px;
  color: #0f0;
  font-family: monospace;
  font-size: 12px;
  background: rgba(0,0,0,0.4);
  padding: 8px;
  border: 1px solid #0f0;
}
</style>
</head>
<body>

<canvas id="gfx"></canvas>
<div id="hud">
WASD mover · Espacio subir · Shift bajar<br>
Click para capturar mouse
</div>

<!-- ================= Vertex Shader ================= -->
<script id="vs" type="x-shader/x-vertex">
#version 300 es
layout(location=0) in vec2 aPos;
layout(location=1) in vec2 aUV;
out vec2 vUV;
void main(){
  vUV = aUV;
  gl_Position = vec4(aPos, 0.0, 1.0);
}
</script>

<!-- ================= Fragment Shader ================= -->
<script id="fs" type="x-shader/x-fragment">
#version 300 es
precision highp float;

in vec2 vUV;
out vec4 fragColor;

uniform vec3 uCamPos;
uniform vec3 uCamFwd;
uniform vec3 uCamRight;
uniform vec3 uCamUp;
uniform vec2 uResolution;
uniform int uFrameIndex;
uniform int uResetAccum;

/* Agujero negro */
uniform vec3 uBHPos;
uniform float uBHMass;
uniform float uBHRadius;

/* RNG */
float rand(vec2 p, float s){
  return fract(sin(dot(p, vec2(12.9898,78.233)) + s) * 43758.5453);
}

/* Curvatura gravitacional */
void bendRay(inout vec3 ro, inout vec3 rd){
  for(int i=0;i<12;i++){
    vec3 toBH = uBHPos - ro;
    float r = length(toBH);

    if(r < uBHRadius){
      rd = vec3(0.0);
      return;
    }

    float force = uBHMass / (r*r + 0.05);
    rd += normalize(toBH) * force * 0.015;
    rd = normalize(rd);
    ro += rd * 0.15;
  }
}

/* Disco de acreción */
vec3 accretionDisk(vec3 p){
  vec3 q = p - uBHPos;
  float d = length(q.xz);
  float h = abs(q.y);
  float ring = smoothstep(2.2, 1.6, d) * smoothstep(0.15, 0.0, h);
  vec3 hot = vec3(1.2, 0.9, 0.6);
  vec3 warm = vec3(1.0, 0.5, 0.2);
  return mix(warm, hot, ring) * ring * 3.0;
}

void main(){
  vec2 uv = vUV * 2.0 - 1.0;
  float aspect = uResolution.x / uResolution.y;
  uv.x *= aspect;

  /* FOV vertical 60° */
  float fov = radians(60.0);
  vec3 dir = normalize(
    uCamFwd +
    uv.x * uCamRight * tan(fov*0.5) +
    uv.y * uCamUp * tan(fov*0.5)
  );

  vec3 ro = uCamPos;
  vec3 rd = dir;

  bendRay(ro, rd);

  if(length(rd) < 0.001){
    fragColor = vec4(0.0);
    return;
  }

  /* Fondo */
  float t = 0.5 * (rd.y + 1.0);
  vec3 sky = mix(vec3(0.6,0.7,1.0), vec3(0.02,0.02,0.05), t);

  vec3 col = sky + accretionDisk(ro);

  fragColor = vec4(col, 1.0);
}
</script>

<!-- ================= JavaScript ================= -->
<script>
const canvas = document.getElementById("gfx");
const gl = canvas.getContext("webgl2", { antialias:false });
if(!gl) alert("WebGL2 no soportado");

function resize(){
  const dpr = devicePixelRatio || 1;
  canvas.width = innerWidth * dpr;
  canvas.height = innerHeight * dpr;
  gl.viewport(0,0,canvas.width,canvas.height);
}
addEventListener("resize", resize);
resize();

/* Compile */
function compile(type, src){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS))
    throw gl.getShaderInfoLog(s);
  return s;
}
function link(vs, fs){
  const p = gl.createProgram();
  gl.attachShader(p, compile(gl.VERTEX_SHADER, vs));
  gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fs));
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS))
    throw gl.getProgramInfoLog(p);
  return p;
}

const prog = link(
  document.getElementById("vs").textContent,
  document.getElementById("fs").textContent
);

/* Quad */
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1,-1, 0,0,
   1,-1, 1,0,
  -1, 1, 0,1,
   1, 1, 1,1
]), gl.STATIC_DRAW);

gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0,2,gl.FLOAT,false,16,0);
gl.enableVertexAttribArray(1);
gl.vertexAttribPointer(1,2,gl.FLOAT,false,16,8);

gl.useProgram(prog);

/* Uniforms */
const U = n => gl.getUniformLocation(prog,n);

let camPos = [0,1.5,6];
let yaw = 0, pitch = 0;
let frame = 0;
let reset = 1;
const keys = {};

onkeydown = e => keys[e.code] = true;
onkeyup   = e => keys[e.code] = false;

canvas.onclick = () => canvas.requestPointerLock();

onmousemove = e => {
  if(document.pointerLockElement !== canvas) return;
  yaw   -= e.movementX * 0.002;
  pitch -= e.movementY * 0.002;
  pitch = Math.max(-1.4, Math.min(1.4, pitch));
  reset = 1;
};

function norm(v){
  const l = Math.hypot(...v);
  return v.map(x=>x/l);
}
function cross(a,b){
  return [
    a[1]*b[2]-a[2]*b[1],
    a[2]*b[0]-a[0]*b[2],
    a[0]*b[1]-a[1]*b[0]
  ];
}

function loop(){
  const fwd = [
    Math.cos(pitch)*Math.sin(yaw),
    Math.sin(pitch),
    Math.cos(pitch)*Math.cos(yaw)
  ];
  const right = norm(cross(fwd,[0,1,0]));
  const up = cross(right,fwd);

  const sp = 0.08;
  if(keys.KeyW) camPos = camPos.map((v,i)=>v+fwd[i]*sp);
  if(keys.KeyS) camPos = camPos.map((v,i)=>v-fwd[i]*sp);
  if(keys.KeyA) camPos = camPos.map((v,i)=>v-right[i]*sp);
  if(keys.KeyD) camPos = camPos.map((v,i)=>v+right[i]*sp);
  if(keys.Space) camPos[1]+=sp;
  if(keys.ShiftLeft) camPos[1]-=sp;

  if(Object.values(keys).some(v=>v)) reset = 1;

  gl.uniform3fv(U("uCamPos"), camPos);
  gl.uniform3fv(U("uCamFwd"), fwd);
  gl.uniform3fv(U("uCamRight"), right);
  gl.uniform3fv(U("uCamUp"), up);
  gl.uniform2f(U("uResolution"), canvas.width, canvas.height);
  gl.uniform1i(U("uFrameIndex"), frame++);
  gl.uniform1i(U("uResetAccum"), reset);

  gl.uniform3f(U("uBHPos"), 0,1,0);
  gl.uniform1f(U("uBHMass"), 6.0);
  gl.uniform1f(U("uBHRadius"), 0.45);

  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
  reset = 0;
  requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
