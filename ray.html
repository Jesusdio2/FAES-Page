<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<title>WebGL Path Tracer – Apple M2</title>
<style>
html,body{margin:0;overflow:hidden;background:#000}
canvas{display:block}
#hud{
  position:fixed;left:10px;top:10px;
  color:#0f0;font-family:monospace;
  background:#0008;padding:6px
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">Frames: 0</div>

<script type="module">
const c = document.getElementById("c");
const gl = c.getContext("webgl2", { antialias:false });
if(!gl) alert("WebGL2 requerido");

let W,H;
function resize(){
  W = c.width = innerWidth;
  H = c.height = innerHeight;
  gl.viewport(0,0,W,H);
}
addEventListener("resize",resize);
resize();

/* ================= SHADERS ================= */

const vs = `#version 300 es
precision highp float;
out vec2 uv;
void main(){
  uv = vec2((gl_VertexID<<1)&2, gl_VertexID&2);
  gl_Position = vec4(uv*2.0-1.0,0,1);
}`;

const fs = `#version 300 es
precision highp float;
out vec4 frag;

in vec2 uv;

uniform vec2 resolution;
uniform int frame;
uniform vec3 camPos;
uniform vec3 camF;
uniform vec3 camR;
uniform vec3 camU;
uniform float fovY;
uniform sampler2D prev;

#define MAX_STEPS 100
#define FAR 100.0

float sdSphere(vec3 p,float r){return length(p)-r;}
float sdPlane(vec3 p){return p.y;}

float map(vec3 p){
  float s = sdSphere(p-vec3(0,1,0),1.0);
  float g = sdPlane(p);
  return min(s,g);
}

vec3 normal(vec3 p){
  vec2 e=vec2(0.001,0);
  return normalize(vec3(
    map(p+e.xyy)-map(p-e.xyy),
    map(p+e.yxy)-map(p-e.yxy),
    map(p+e.yyx)-map(p-e.yyx)
  ));
}

vec3 sky(vec3 rd){
  float t = max(rd.y,0.0);
  return mix(vec3(0.6,0.7,0.9),vec3(0.1,0.15,0.3),pow(1.0-t,2.0));
}

void main(){
  vec2 p = uv*2.0-1.0;
  float aspect = resolution.x/resolution.y;
  p.x *= aspect;

  float scale = tan(fovY*0.5);
  vec3 rd = normalize(camF + p.x*camR*scale + p.y*camU*scale);
  vec3 ro = camPos;

  float t=0.0;
  bool hit=false;
  for(int i=0;i<MAX_STEPS;i++){
    vec3 pos = ro + rd*t;
    float d = map(pos);
    if(d<0.001){hit=true;break;}
    t += d;
    if(t>FAR) break;
  }

  vec3 col;
  if(hit){
    vec3 pos = ro + rd*t;
    vec3 n = normal(pos);

    // ☀️ Sol direccional
    vec3 sunDir = normalize(vec3(0.6,1.0,0.4));
    float diff = clamp(dot(n,sunDir),0.0,1.0);

    bool ground = abs(pos.y)<0.01;
    vec3 base = ground ? vec3(0.8) : vec3(1.0,0.2,0.2);

    col = base * diff + base*0.1;
  }else{
    col = sky(rd);
  }

  vec3 prevCol = texture(prev, uv).rgb;
  float f = float(frame);
  col = mix(prevCol, col, 1.0/(f+1.0));

  frag = vec4(col,1);
}
`;

/* ================= PROGRAM ================= */

function compile(type,src){
  const s=gl.createShader(type);
  gl.shaderSource(s,src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))
    throw gl.getShaderInfoLog(s);
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog,compile(gl.VERTEX_SHADER,vs));
gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,fs));
gl.linkProgram(prog);
gl.useProgram(prog);

/* ================= TEXTURES ================= */

function tex(){
  const t=gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D,t);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA32F,W,H,0,gl.RGBA,gl.FLOAT,null);
  return t;
}

let A=tex(),B=tex();

/* ================= CAMERA ================= */

let camPos=[0,1.5,5];
let yaw=0,pitch=0;
const keys={};

onkeydown=e=>keys[e.code]=true;
onkeyup=e=>keys[e.code]=false;

c.onclick=()=>c.requestPointerLock();
onmousemove=e=>{
  if(document.pointerLockElement!==c) return;
  yaw -= e.movementX*0.002;
  pitch -= e.movementY*0.002;
  pitch=Math.max(-1.5,Math.min(1.5,pitch));
  frame=0;
};

/* ================= LOOP ================= */

let frame=0;
const hud=document.getElementById("hud");

function loop(){
  // camera vectors
  const fx=Math.cos(pitch)*Math.sin(yaw);
  const fy=Math.sin(pitch);
  const fz=Math.cos(pitch)*Math.cos(yaw);
  const F=[fx,fy,fz];
  const R=[Math.cos(yaw),0,-Math.sin(yaw)];
  const U=[
    R[1]*F[2]-R[2]*F[1],
    R[2]*F[0]-R[0]*F[2],
    R[0]*F[1]-R[1]*F[0]
  ];

  const speed=0.08;
  if(keys.KeyW){camPos[0]+=F[0]*speed;camPos[1]+=F[1]*speed;camPos[2]+=F[2]*speed;frame=0;}
  if(keys.KeyS){camPos[0]-=F[0]*speed;camPos[1]-=F[1]*speed;camPos[2]-=F[2]*speed;frame=0;}
  if(keys.KeyA){camPos[0]-=R[0]*speed;camPos[2]-=R[2]*speed;frame=0;}
  if(keys.KeyD){camPos[0]+=R[0]*speed;camPos[2]+=R[2]*speed;frame=0;}
  if(keys.Space){camPos[1]+=speed;frame=0;}
  if(keys.ShiftLeft){camPos[1]-=speed;frame=0;}

  gl.useProgram(prog);

  gl.uniform2f(gl.getUniformLocation(prog,"resolution"),W,H);
  gl.uniform1i(gl.getUniformLocation(prog,"frame"),frame);
  gl.uniform3fv(gl.getUniformLocation(prog,"camPos"),camPos);
  gl.uniform3fv(gl.getUniformLocation(prog,"camF"),F);
  gl.uniform3fv(gl.getUniformLocation(prog,"camR"),R);
  gl.uniform3fv(gl.getUniformLocation(prog,"camU"),U);
  gl.uniform1f(gl.getUniformLocation(prog,"fovY"),60*Math.PI/180);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D,A);
  gl.uniform1i(gl.getUniformLocation(prog,"prev"),0);

  gl.drawArrays(gl.TRIANGLES,0,3);

  [A,B]=[B,A];
  frame++;
  hud.textContent="Frames acumulados: "+frame;
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
