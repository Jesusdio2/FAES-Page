<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>WebGL2 Ray Tracing WASD + Calidad dinámica</title>
  <style>
    html, body { margin:0; height:100%; background:#000; }
    canvas { width:100vw; height:100vh; display:block; }
    #hud {
      position:fixed; top:10px; left:10px; color:#0f0; font:12px/1.4 monospace;
      background:rgba(0,0,0,0.4); padding:8px; border:1px solid #0f0;
    }
  </style>
</head>
<body>
  <canvas id="gfx"></canvas>
  <div id="hud">WASD: mover | Espacio: subir | Shift: bajar | FPS: <span id="fps">0</span><br>
  scale:<span id="scale">1.00</span> spp:<span id="spp">4</span> bounces:<span id="bounces">3</span></div>

<script>
const canvas = document.getElementById("gfx");
const hudFPS = document.getElementById("fps");
const hudScale = document.getElementById("scale");
const hudSPP = document.getElementById("spp");
const hudBounces = document.getElementById("bounces");

const gl = canvas.getContext("webgl2", { antialias: false });
if (!gl) { alert("Tu navegador no soporta WebGL2"); throw new Error("WebGL2 no disponible"); }
const extColorFloat = gl.getExtension("EXT_color_buffer_float");
const extTexFloatLinear = gl.getExtension("OES_texture_float_linear"); // mejora el blit
if (!extColorFloat) console.warn("EXT_color_buffer_float no disponible: usando RGBA8 en vez de RGBA16F");

function resize() {
  const w = canvas.clientWidth | 0;
  const h = canvas.clientHeight | 0;
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w; canvas.height = h;
    recreateTargets();
  }
}
window.addEventListener("resize", resize);
resize();

/* --------- Cámara e input --------- */
let camPos = [0, 1.2, 4.0];
let camYaw = 0.0;
let camPitch = 0.0;
let moveSpeed = 2.5;
let keys = new Set();
let mouseDown = false;
let lastMouse = {x:0,y:0};

document.addEventListener("keydown", (e)=> keys.add(e.code));
document.addEventListener("keyup", (e)=> keys.delete(e.code));
canvas.addEventListener("mousedown", (e)=> { mouseDown = true; lastMouse.x=e.clientX; lastMouse.y=e.clientY; });
document.addEventListener("mouseup", ()=> mouseDown=false);
document.addEventListener("mousemove", (e)=>{
  if (!mouseDown) return;
  const dx = e.clientX - lastMouse.x;
  const dy = e.clientY - lastMouse.y;
  lastMouse.x = e.clientX; lastMouse.y = e.clientY;
  const sens = 0.0025;
  camYaw += dx * sens;
  camPitch = Math.max(-1.2, Math.min(1.2, camPitch - dy * sens));
  cameraMoved();
});

function forwardVector() {
  const cy = Math.cos(camYaw), sy = Math.sin(camYaw);
  const cp = Math.cos(camPitch), sp = Math.sin(camPitch);
  const f = [sy*cp, sp, -cy*cp];
  const n = Math.hypot(f[0], f[1], f[2]); return [f[0]/n, f[1]/n, f[2]/n];
}
function rightVector() {
  const f = forwardVector();
  const up = [0,1,0];
  const r = [
    f[1]*up[2] - f[2]*up[1],
    f[2]*up[0] - f[0]*up[2],
    f[0]*up[1] - f[1]*up[0]
  ];
  const n = Math.hypot(r[0], r[1], r[2]); return [r[0]/n, r[1]/n, r[2]/n];
}
function updateCamera(dt) {
  const f = forwardVector();
  const r = rightVector();
  let dx=0,dy=0,dz=0;
  if (keys.has("KeyW")) { dx += f[0]*moveSpeed*dt; dy += f[1]*moveSpeed*dt; dz += f[2]*moveSpeed*dt; }
  if (keys.has("KeyS")) { dx -= f[0]*moveSpeed*dt; dy -= f[1]*moveSpeed*dt; dz -= f[2]*moveSpeed*dt; }
  if (keys.has("KeyA")) { dx -= r[0]*moveSpeed*dt; dy -= r[1]*moveSpeed*dt; dz -= r[2]*moveSpeed*dt; }
  if (keys.has("KeyD")) { dx += r[0]*moveSpeed*dt; dy += r[1]*moveSpeed*dt; dz += r[2]*moveSpeed*dt; }
  if (keys.has("Space")) { dy += moveSpeed*dt; }
  if (keys.has("ShiftLeft") || keys.has("ShiftRight")) { dy -= moveSpeed*dt; }
  if (dx || dy || dz) cameraMoved();
  camPos[0] += dx; camPos[1] += dy; camPos[2] += dz;
}

/* --------- Calidad dinámica --------- */
const targetFPS = 60;
const targetFrameMs = 1000/targetFPS;
let quality = { scale: 1.0, spp: 4, bounces: 3 };
let stableFrames = 0;
let moving = false;
let resetAccumulation = 1;
let lastPose = { pos: camPos.slice(), yaw: camYaw, pitch: camPitch };

function poseDelta() {
  const dp = [
    camPos[0]-lastPose.pos[0],
    camPos[1]-lastPose.pos[1],
    camPos[2]-lastPose.pos[2]
  ];
  const ang = Math.abs(camYaw - lastPose.yaw) + Math.abs(camPitch - lastPose.pitch);
  const mag = Math.hypot(dp[0], dp[1], dp[2]) + ang;
  lastPose.pos = camPos.slice();
  lastPose.yaw = camYaw; lastPose.pitch = camPitch;
  return mag;
}
function cameraMoved(){ moving = true; resetAccumulation = 1; }
function updateAdaptive(frameMs) {
  const motion = poseDelta();
  moving = motion > 0.001 || frameMs > targetFrameMs;
  if (moving) {
    quality.scale = Math.max(0.55, quality.scale * 0.92);
    quality.spp = Math.max(1, Math.floor(quality.spp * 0.75));
    quality.bounces = Math.max(2, quality.bounces - 1);
    resetAccumulation = 1;
    stableFrames = 0;
  } else {
    stableFrames++;
    if (stableFrames > 12) {
      quality.scale = Math.min(1.0, quality.scale * 1.04);
      if (quality.spp < 8) quality.spp += 1;
      if (quality.bounces < 4) quality.bounces += 1;
    }
  }
  hudScale.textContent = quality.scale.toFixed(2);
  hudSPP.textContent = String(quality.spp);
  hudBounces.textContent = String(quality.bounces);
}

/* --------- Shaders --------- */
const vsQuad = `#version 300 es
layout(location=0) in vec2 aPos;
layout(location=1) in vec2 aUV;
out vec2 vUV;
void main(){
  vUV = aUV;
  gl_Position = vec4(aPos, 0.0, 1.0);
}
`;

const fsPathTrace = `#version 300 es
precision highp float;
in vec2 vUV;
out vec4 fragColor;

uniform vec3 uCamPos;
uniform vec3 uCamFwd;
uniform vec3 uCamRight;
uniform vec3 uCamUp;

uniform vec2 uResolution;
uniform float uScale;
uniform int uSPP;
uniform int uBounces;
uniform int uResetAccum;
uniform int uFrameIndex;

uniform sampler2D uHistory;

// Escena: 4 esferas (centro.xyz, radio, color.rgb, roughness)
uniform vec4 uSphereCenterRadius[4];
uniform vec4 uSphereColorRough[4];

float rand(vec2 p, float seed){
  return fract(sin(dot(p, vec2(12.9898, 78.233)) + seed) * 43758.5453);
}
vec3 sampleHemisphere(vec3 n, vec2 rnd){
  float phi = 6.2831853 * rnd.x;
  float cosTheta = sqrt(1.0 - rnd.y);
  float sinTheta = sqrt(1.0 - cosTheta*cosTheta);
  vec3 up = abs(n.y) > 0.99 ? vec3(1,0,0) : vec3(0,1,0);
  vec3 t = normalize(cross(up, n));
  vec3 b = cross(n, t);
  return normalize(t*(cos(phi)*sinTheta) + b*(sin(phi)*sinTheta) + n*cosTheta);
}

bool intersectSphere(vec3 ro, vec3 rd, vec4 scR, out float t, out vec3 n){
  vec3 oc = ro - scR.xyz;
  float b = dot(oc, rd);
  float c = dot(oc, oc) - scR.w*scR.w;
  float h = b*b - c;
  if (h < 0.0) { t = -1.0; return false; }
  float tt = -b - sqrt(h);
  if (tt < 0.0001) { t = -1.0; return false; }
  t = tt;
  vec3 p = ro + rd * t;
  n = normalize(p - scR.xyz);
  return true;
}

struct Hit { vec3 p; vec3 n; vec3 color; float rough; bool ok; };

Hit traceScene(vec3 ro, vec3 rd){
  float tMin = 1e9; Hit h; h.ok=false;
  for (int i=0; i<4; ++i){
    float t; vec3 n;
    if (intersectSphere(ro, rd, uSphereCenterRadius[i], t, n)){
      if (t > 0.0 && t < tMin){
        tMin = t; h.ok = true;
        h.p = ro + rd * t;
        h.n = n;
        h.color = uSphereColorRough[i].xyz;
        h.rough = uSphereColorRough[i].w;
      }
    }
  }
  return h;
}

void main(){
  vec2 res = uResolution * uScale;
  vec2 uv = vUV; // ya va de 0..1 en texcoord del quad
  vec2 ndc = uv*2.0 - 1.0;

  vec3 col = vec3(0.0);
  float seedBase = float(uFrameIndex);

  for (int s=0; s<uSPP; ++s){
    float j1 = rand(uv, seedBase + float(s));
    float j2 = rand(uv + 0.37, seedBase + float(s)*1.3);
    vec3 dir = normalize(uCamFwd + uCamRight*ndc.x + uCamUp*ndc.y);

    vec3 rayO = uCamPos;
    vec3 rayD = dir;
    vec3 throughput = vec3(1.0);
    vec3 radiance = vec3(0.0);

    for (int b=0; b<uBounces; ++b){
      Hit h = traceScene(rayO, rayD);
      if (!h.ok){
        float t = 0.5*(rayD.y+1.0);
        vec3 sky = mix(vec3(0.6,0.7,1.0), vec3(0.1,0.1,0.12), t);
        radiance += throughput * sky;
        break;
      }
      float nl = max(dot(h.n, vec3(0,1,0)), 0.0);
      vec3 sky = vec3(0.8,0.85,1.0)*0.1;
      radiance += throughput * (h.color * (0.05 + 0.95*nl) + sky*0.05);

      float r1 = rand(uv + vec2(float(b),0.0), seedBase + float(s)*2.1);
      float r2 = rand(uv + vec2(0.0,float(b)), seedBase + float(s)*3.7);
      vec3 hemi = sampleHemisphere(h.n, vec2(r1,r2));
      rayO = h.p + h.n*0.001;
      rayD = normalize(mix(reflect(rayD, h.n), hemi, h.rough));
      throughput *= h.color;
    }
    col += radiance;
  }
  col /= float(uSPP);

  if (uResetAccum == 0) {
    vec3 prev = texture(uHistory, uv).rgb;
    col = mix(prev, col, 0.1);
  }

  fragColor = vec4(col, 1.0);
}
`;

const fsBlit = `#version 300 es
precision highp float;
in vec2 vUV;
out vec4 fragColor;
uniform sampler2D uSrc;
void main(){
  fragColor = texture(uSrc, vUV);
}
`;

/* --------- Programas --------- */
function compile(type, src){
  const s = gl.createShader(type);
  gl.shaderSource(s, src); gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s)); throw new Error("Shader error");
  }
  return s;
}
function linkProgram(vsSrc, fsSrc){
  const vs = compile(gl.VERTEX_SHADER, vsSrc);
  const fs = compile(gl.FRAGMENT_SHADER, fsSrc);
  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs);
  gl.bindAttribLocation(p, 0, "aPos");
  gl.bindAttribLocation(p, 1, "aUV");
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(p)); throw new Error("Program link error");
  }
  return p;
}
const progTrace = linkProgram(vsQuad, fsPathTrace);
const progBlit = linkProgram(vsQuad, fsBlit);

/* --------- Fullscreen quad --------- */
const quadVAO = gl.createVertexArray();
gl.bindVertexArray(quadVAO);
const quadVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
const quadData = new Float32Array([
  // pos    // uv
  -1,-1,   0,1,
   1,-1,   1,1,
  -1, 1,   0,0,
  -1, 1,   0,0,
   1,-1,   1,1,
   1, 1,   1,0
]);
gl.bufferData(gl.ARRAY_BUFFER, quadData, gl.STATIC_DRAW);
gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0);
gl.enableVertexAttribArray(1);
gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8);
gl.bindVertexArray(null);

/* --------- Render targets y FBOs --------- */
let rtWidth=0, rtHeight=0;
let rtColor = null, rtFBO = null;
let historyTex = null;

function makeTexture(w, h, float16=false){
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, extTexFloatLinear ? gl.LINEAR : gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  if (float16 && extColorFloat) {
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, w, h, 0, gl.RGBA, gl.FLOAT, null);
  } else {
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  }
  gl.bindTexture(gl.TEXTURE_2D, null);
  return tex;
}

function recreateTargets() {
  const scale = quality.scale;
  rtWidth = Math.max(1, Math.floor(canvas.width * scale));
  rtHeight = Math.max(1, Math.floor(canvas.height * scale));

  if (rtColor) { gl.deleteTexture(rtColor); rtColor=null; }
  if (historyTex) { gl.deleteTexture(historyTex); historyTex=null; }
  if (rtFBO) { gl.deleteFramebuffer(rtFBO); rtFBO=null; }

  rtColor = makeTexture(rtWidth, rtHeight, true);
  historyTex = makeTexture(rtWidth, rtHeight, true);

  rtFBO = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, rtFBO);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rtColor, 0);
  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
  if (status !== gl.FRAMEBUFFER_COMPLETE) {
    console.warn("FBO incompleto, usando RGBA8 en lugar de RGBA16F");
    gl.deleteTexture(rtColor);
    gl.deleteTexture(historyTex);
    rtColor = makeTexture(rtWidth, rtHeight, false);
    historyTex = makeTexture(rtWidth, rtHeight, false);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rtColor, 0);
  }
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  resetAccumulation = 1;
}

/* --------- Uniform locations --------- */
gl.useProgram(progTrace);
const loc = {
  uCamPos: gl.getUniformLocation(progTrace, "uCamPos"),
  uCamFwd: gl.getUniformLocation(progTrace, "uCamFwd"),
  uCamRight: gl.getUniformLocation(progTrace, "uCamRight"),
  uCamUp: gl.getUniformLocation(progTrace, "uCamUp"),
  uResolution: gl.getUniformLocation(progTrace, "uResolution"),
  uScale: gl.getUniformLocation(progTrace, "uScale"),
  uSPP: gl.getUniformLocation(progTrace, "uSPP"),
  uBounces: gl.getUniformLocation(progTrace, "uBounces"),
  uResetAccum: gl.getUniformLocation(progTrace, "uResetAccum"),
  uFrameIndex: gl.getUniformLocation(progTrace, "uFrameIndex"),
  uHistory: gl.getUniformLocation(progTrace, "uHistory"),
  uSphereCenterRadius: [
    gl.getUniformLocation(progTrace, "uSphereCenterRadius[0]"),
    gl.getUniformLocation(progTrace, "uSphereCenterRadius[1]"),
    gl.getUniformLocation(progTrace, "uSphereCenterRadius[2]"),
    gl.getUniformLocation(progTrace, "uSphereCenterRadius[3]")
  ],
  uSphereColorRough: [
    gl.getUniformLocation(progTrace, "uSphereColorRough[0]"),
    gl.getUniformLocation(progTrace, "uSphereColorRough[1]"),
    gl.getUniformLocation(progTrace, "uSphereColorRough[2]"),
    gl.getUniformLocation(progTrace, "uSphereColorRough[3]")
  ]
};
gl.useProgram(progBlit);
const locBlit = { uSrc: gl.getUniformLocation(progBlit, "uSrc") };

/* --------- Escena --------- */
const spheresCenterRadius = [
  [ 0.0, -1001.0,  0.0, 1000.0], // suelo
  [-1.5,    1.0,  0.0,    1.0], // roja
  [ 1.5,    1.0,  0.0,    1.0], // verde
  [ 0.0,    0.8, -2.0,    0.8]  // metal
];
const spheresColorRough = [
  [0.8,0.8,0.8, 0.9],
  [1.0,0.2,0.2, 0.6],
  [0.2,1.0,0.2, 0.6],
  [0.9,0.9,1.0, 0.2]
];

/* --------- Bucle de render --------- */
let frameIndex = 0;
let lastTime = performance.now();

function render() {
  const now = performance.now();
  const dt = Math.min(0.1, (now - lastTime)/1000);
  lastTime = now;

  updateCamera(dt);

  // recrea targets si cambió tamaño o escala
  const desiredW = Math.max(1, Math.floor(canvas.width * quality.scale));
  const desiredH = Math.max(1, Math.floor(canvas.height * quality.scale));
  if (desiredW !== rtWidth || desiredH !== rtHeight) recreateTargets();

  // 1) Path tracing a rtColor
  gl.bindFramebuffer(gl.FRAMEBUFFER, rtFBO);
  gl.viewport(0, 0, rtWidth, rtHeight);
  gl.useProgram(progTrace);
  gl.bindVertexArray(quadVAO);

  const f = forwardVector();
  const r = rightVector();
  const u = (function(){ // up = normalize(cross(r, f))
    const c = [ r[1]*f[2]-r[2]*f[1], r[2]*f[0]-r[0]*f[2], r[0]*f[1]-r[1]*f[0] ];
    const n = Math.hypot(c[0], c[1], c[2]); return [c[0]/n, c[1]/n, c[2]/n];
  })();

  gl.uniform3fv(loc.uCamPos, camPos);
  gl.uniform3fv(loc.uCamFwd, f);
  gl.uniform3fv(loc.uCamRight, r);
  gl.uniform3fv(loc.uCamUp, u);
  gl.uniform2f(loc.uResolution, canvas.width, canvas.height);
  gl.uniform1f(loc.uScale, quality.scale);
  gl.uniform1i(loc.uSPP, quality.spp);
  gl.uniform1i(loc.uBounces, quality.bounces);
  gl.uniform1i(loc.uResetAccum, resetAccumulation);
  gl.uniform1i(loc.uFrameIndex, frameIndex);

  // escena
  for (let i=0;i<4;i++){
    gl.uniform4fv(loc.uSphereCenterRadius[i], spheresCenterRadius[i]);
    gl.uniform4fv(loc.uSphereColorRough[i], spheresColorRough[i]);
  }

  // history texture
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, historyTex);
  gl.uniform1i(loc.uHistory, 0);

  gl.drawArrays(gl.TRIANGLES, 0, 6);
  gl.bindVertexArray(null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  // 2) Blit a pantalla (upsampling)
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.useProgram(progBlit);
  gl.bindVertexArray(quadVAO);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, rtColor);
  gl.uniform1i(locBlit.uSrc, 0);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  gl.bindVertexArray(null);

  // 3) Copiar rtColor -> history para acumulación del siguiente frame
  gl.bindFramebuffer(gl.FRAMEBUFFER, rtFBO);
  gl.bindTexture(gl.TEXTURE_2D, historyTex);
  // swap: render copiado a history (simplem. re-render con blit shader a history)
  // Creamos FBO temporal para historyTex
  const fboHist = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fboHist);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, historyTex, 0);
  gl.viewport(0, 0, rtWidth, rtHeight);
  gl.useProgram(progBlit);
  gl.bindVertexArray(quadVAO);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, rtColor);
  gl.uniform1i(locBlit.uSrc, 0);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  gl.bindVertexArray(null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.deleteFramebuffer(fboHist);

  frameIndex++;
  const frameMs = performance.now() - now;
  hudFPS.textContent = (1000/frameMs).toFixed(1);
  updateAdaptive(frameMs);
  resetAccumulation = 0;

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
