<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<title>Path Tracer WebGL2 FUNCIONANDO</title>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden}
canvas{width:100%;height:100%;display:block}
#hud{
 position:fixed;left:10px;top:10px;
 color:#0f0;font:12px monospace;
 background:rgba(0,0,0,.4);
 padding:8px;border:1px solid #0f0
}
</style>
</head>
<body>

<canvas id="c"></canvas>
<div id="hud">
WASD mover · Espacio subir · Shift bajar<br>
Frames: <span id="f">0</span>
</div>

<script>
const c=document.getElementById("c");
const gl=c.getContext("webgl2");
if(!gl){alert("WebGL2 no disponible");throw 0;}

function resize(){
 c.width=innerWidth;
 c.height=innerHeight;
 gl.viewport(0,0,c.width,c.height);
}
addEventListener("resize",resize);
resize();

/* ========= SHADERS ========= */

const vs=`#version 300 es
layout(location=0) in vec2 p;
out vec2 uv;
void main(){
 uv=p*0.5+0.5;
 gl_Position=vec4(p,0,1);
}`;

const fs=`#version 300 es
precision highp float;
in vec2 uv;
out vec4 frag;

uniform vec3 camPos,camF,camR,camU;
uniform sampler2D history;
uniform int frame;

float rand(vec2 p){return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);}

bool sphere(vec3 ro,vec3 rd,vec3 c,float r,out float t,out vec3 n){
 vec3 oc=ro-c;
 float b=dot(oc,rd);
 float h=b*b-dot(oc,oc)+r*r;
 if(h<0.)return false;
 t=-b-sqrt(h);
 if(t<0.)return false;
 n=normalize(ro+rd*t-c);
 return true;
}

void main(){
 vec2 p=uv*2.-1.;
 vec3 rd=normalize(camF+p.x*camR+p.y*camU);
 vec3 ro=camPos;

 vec3 col=vec3(0);
 vec3 tp=vec3(1);

 for(int i=0;i<3;i++){
  float t; vec3 n;
  if(sphere(ro,rd,vec3(0,1,0),1.,t,n)){
   ro+=rd*t+n*0.001;
   rd=normalize(n+vec3(
     rand(uv+float(frame)),
     rand(uv+2.),
     rand(uv+4.)
   )-0.5);
   col+=tp*vec3(1,0.3,0.2);
   tp*=0.5;
  }else{
   col+=tp*mix(vec3(0.6,0.7,1),vec3(0.1),rd.y*0.5+0.5);
   break;
  }
 }

 vec3 prev=texture(history,uv).rgb;
 float a=frame==0?1.:1./float(frame+1);
 frag=vec4(mix(prev,col,a),1);
}`;

/* ========= PROGRAMA ========= */

function sh(t,s){
 const x=gl.createShader(t);
 gl.shaderSource(x,s);
 gl.compileShader(x);
 if(!gl.getShaderParameter(x,gl.COMPILE_STATUS))
  throw gl.getShaderInfoLog(x);
 return x;
}
const prog=gl.createProgram();
gl.attachShader(prog,sh(gl.VERTEX_SHADER,vs));
gl.attachShader(prog,sh(gl.FRAGMENT_SHADER,fs));
gl.linkProgram(prog);
gl.useProgram(prog);

/* ========= QUAD ========= */

const vao=gl.createVertexArray();
gl.bindVertexArray(vao);
const vbo=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,vbo);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([
 -1,-1, 1,-1, -1,1, 1,1
]),gl.STATIC_DRAW);
gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);

/* ========= TEXTURAS ========= */

function tex(){
 const t=gl.createTexture();
 gl.bindTexture(gl.TEXTURE_2D,t);
 gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,
  c.width,c.height,0,
  gl.RGBA,gl.UNSIGNED_BYTE,null);
 gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);
 gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);
 return t;
}
let A=tex(),B=tex();
const fb=gl.createFramebuffer();

/* ========= CÁMARA ========= */

let cam=[0,1.2,4],yaw=0,frame=0;
const k=new Set();
onkeydown=e=>k.add(e.code);
onkeyup=e=>k.delete(e.code);

c.onclick=()=>c.requestPointerLock();
onmousemove=e=>{
 if(document.pointerLockElement!==c)return;
 yaw-=e.movementX*0.002;
 frame=0;
};

function update(dt){
 const sp=dt*3;
 const f=[Math.sin(yaw),0,-Math.cos(yaw)];
 const r=[Math.cos(yaw),0,Math.sin(yaw)];
 if(k.has("KeyW")){cam[0]+=f[0]*sp;cam[2]+=f[2]*sp;frame=0;}
 if(k.has("KeyS")){cam[0]-=f[0]*sp;cam[2]-=f[2]*sp;frame=0;}
 if(k.has("KeyA")){cam[0]-=r[0]*sp;cam[2]-=r[2]*sp;frame=0;}
 if(k.has("KeyD")){cam[0]+=r[0]*sp;cam[2]+=r[2]*sp;frame=0;}
 if(k.has("Space")){cam[1]+=sp;frame=0;}
 if(k.has("ShiftLeft")){cam[1]-=sp;frame=0;}
}

/* ========= LOOP ========= */

let last=performance.now();
function loop(t){
 const dt=(t-last)/1000; last=t;
 update(dt);

 gl.bindFramebuffer(gl.FRAMEBUFFER,fb);
 gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,
  gl.TEXTURE_2D,B,0);

 gl.useProgram(prog);
 gl.uniform3fv(gl.getUniformLocation(prog,"camPos"),cam);
 gl.uniform3fv(gl.getUniformLocation(prog,"camF"),
  [Math.sin(yaw),0,-Math.cos(yaw)]);
 gl.uniform3fv(gl.getUniformLocation(prog,"camR"),
  [Math.cos(yaw),0,Math.sin(yaw)]);
 gl.uniform3fv(gl.getUniformLocation(prog,"camU"),[0,1,0]);
 gl.uniform1i(gl.getUniformLocation(prog,"frame"),frame);

 gl.activeTexture(gl.TEXTURE0);
 gl.bindTexture(gl.TEXTURE_2D,A);
 gl.uniform1i(gl.getUniformLocation(prog,"history"),0);

 gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

 gl.bindFramebuffer(gl.READ_FRAMEBUFFER,fb);
 gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER,null);
 gl.blitFramebuffer(0,0,c.width,c.height,0,0,c.width,c.height,
  gl.COLOR_BUFFER_BIT,gl.NEAREST);

 [A,B]=[B,A];
 document.getElementById("f").textContent=frame++;
 requestAnimationFrame(loop);
}
loop(last);
</script>
</body>
</html>
