<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<title>Path Tracer WebGL2 – Apple M2</title>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden}
canvas{width:100%;height:100%;display:block}
#hud{
 position:fixed;left:10px;top:10px;
 color:#0f0;font:12px monospace;
 background:rgba(0,0,0,.45);
 padding:8px;border:1px solid #0f0
}
</style>
</head>
<body>

<canvas id="c"></canvas>
<div id="hud">
WASD mover · Espacio subir · Shift bajar<br>
Frames acumulados: <span id="f">0</span>
</div>

<script>
/* ================= CONTEXTO ================= */
const c=document.getElementById("c");
const gl=c.getContext("webgl2",{antialias:true});
if(!gl){alert("WebGL2 no disponible");throw 0;}

function resize(){
 c.width=innerWidth;
 c.height=innerHeight;
 gl.viewport(0,0,c.width,c.height);
}
addEventListener("resize",resize);
resize();

/* ================= SHADERS ================= */
const vs=`#version 300 es
layout(location=0) in vec2 p;
out vec2 uv;
void main(){
 uv=p*0.5+0.5;
 gl_Position=vec4(p,0,1);
}`;

const fsTrace=`#version 300 es
precision highp float;
in vec2 uv;
out vec4 frag;

uniform vec3 camPos,camF,camR,camU;
uniform sampler2D history;
uniform int frame;

float rand(vec2 p){
 return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);
}

/* -------- Intersecciones -------- */
bool sphere(vec3 ro,vec3 rd,vec3 c,float r,out float t,out vec3 n){
 vec3 oc=ro-c;
 float b=dot(oc,rd);
 float h=b*b-dot(oc,oc)+r*r;
 if(h<0.)return false;
 t=-b-sqrt(h);
 if(t<0.)return false;
 n=normalize(ro+rd*t-c);
 return true;
}

bool plane(vec3 ro,vec3 rd,out float t,out vec3 n){
 if(abs(rd.y)<1e-3)return false;
 t=-ro.y/rd.y;
 if(t<0.)return false;
 n=vec3(0,1,0);
 return true;
}

void main(){
 vec2 p=uv*2.-1.;
 vec3 rd=normalize(camF+p.x*camR+p.y*camU);
 vec3 ro=camPos;

 vec3 col=vec3(0);
 vec3 tp=vec3(1);

 vec3 sunDir=normalize(vec3(0.4,0.8,0.2));
 vec3 sunCol=vec3(1.0,0.95,0.8)*2.5;

 for(int b=0;b<3;b++){
  float t; vec3 n;
  bool hit=false;
  vec3 hcol;

  if(sphere(ro,rd,vec3(0,1,0),1.,t,n)){
   hit=true;
   hcol=vec3(1,0.3,0.25);
  }

  float tp2; vec3 np;
  if(plane(ro,rd,tp2,np)){
   if(!hit || tp2<t){
    hit=true;
    t=tp2; n=np;
    hcol=vec3(0.6);
   }
  }

  if(!hit){
   vec3 sky=mix(vec3(0.6,0.7,1.0),vec3(0.1),rd.y*0.5+0.5);
   col+=tp*sky;
   break;
  }

  vec3 pos=ro+rd*t;
  float nl=max(dot(n,sunDir),0.);
  col+=tp*(hcol*(0.05+nl*sunCol));

  vec3 hemi=normalize(n+vec3(
   rand(uv+float(frame)),
   rand(uv+2.),
   rand(uv+4.)
  )-0.5);

  ro=pos+n*0.001;
  rd=hemi;
  tp*=hcol*0.6;
 }

 vec3 prev=texture(history,uv).rgb;
 float a=frame==0?1.:1./float(frame+1);
 frag=vec4(mix(prev,col,a),1);
}`;

const fsDisplay=`#version 300 es
precision highp float;
in vec2 uv;
out vec4 frag;
uniform sampler2D img;
void main(){ frag=texture(img,uv); }`;

/* ================= PROGRAMAS ================= */
function prog(v,f){
 const p=gl.createProgram();
 const sv=gl.createShader(gl.VERTEX_SHADER);
 const sf=gl.createShader(gl.FRAGMENT_SHADER);
 gl.shaderSource(sv,v); gl.compileShader(sv);
 gl.shaderSource(sf,f); gl.compileShader(sf);
 gl.attachShader(p,sv); gl.attachShader(p,sf);
 gl.linkProgram(p);
 return p;
}

const traceP=prog(vs,fsTrace);
const dispP=prog(vs,fsDisplay);

/* ================= VAO ================= */
const vao=gl.createVertexArray();
gl.bindVertexArray(vao);
const vbo=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,vbo);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([
 -1,-1, 1,-1, -1,1, 1,1
]),gl.STATIC_DRAW);
gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);

/* ================= TEXTURAS ================= */
function makeTex(){
 const t=gl.createTexture();
 gl.bindTexture(gl.TEXTURE_2D,t);
 gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,
  c.width,c.height,0,
  gl.RGBA,gl.UNSIGNED_BYTE,null);
 gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);
 gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);
 return t;
}
let A=makeTex(),B=makeTex();
const fb=gl.createFramebuffer();

/* ================= CÁMARA ================= */
let cam=[0,1.5,4],yaw=0,frame=0;
const keys=new Set();
onkeydown=e=>keys.add(e.code);
onkeyup=e=>keys.delete(e.code);
c.onclick=()=>c.requestPointerLock();

onmousemove=e=>{
 if(document.pointerLockElement!==c)return;
 yaw-=e.movementX*0.002;
 frame=0;
};

function update(dt){
 const sp=dt*3;
 const f=[Math.sin(yaw),0,-Math.cos(yaw)];
 const r=[Math.cos(yaw),0,Math.sin(yaw)];
 if(keys.has("KeyW")){cam[0]+=f[0]*sp;cam[2]+=f[2]*sp;frame=0;}
 if(keys.has("KeyS")){cam[0]-=f[0]*sp;cam[2]-=f[2]*sp;frame=0;}
 if(keys.has("KeyA")){cam[0]-=r[0]*sp;cam[2]-=r[2]*sp;frame=0;}
 if(keys.has("KeyD")){cam[0]+=r[0]*sp;cam[2]+=r[2]*sp;frame=0;}
 if(keys.has("Space")){cam[1]+=sp;frame=0;}
 if(keys.has("ShiftLeft")){cam[1]-=sp;frame=0;}
}

/* ================= LOOP ================= */
let last=performance.now();
function loop(t){
 const dt=(t-last)/1000; last=t;
 update(dt);

 gl.bindFramebuffer(gl.FRAMEBUFFER,fb);
 gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,
  gl.TEXTURE_2D,B,0);

 gl.useProgram(traceP);
 gl.uniform3fv(gl.getUniformLocation(traceP,"camPos"),cam);
 gl.uniform3fv(gl.getUniformLocation(traceP,"camF"),
  [Math.sin(yaw),0,-Math.cos(yaw)]);
 gl.uniform3fv(gl.getUniformLocation(traceP,"camR"),
  [Math.cos(yaw),0,Math.sin(yaw)]);
 gl.uniform3fv(gl.getUniformLocation(traceP,"camU"),[0,1,0]);
 gl.uniform1i(gl.getUniformLocation(traceP,"frame"),frame);

 gl.activeTexture(gl.TEXTURE0);
 gl.bindTexture(gl.TEXTURE_2D,A);
 gl.uniform1i(gl.getUniformLocation(traceP,"history"),0);

 gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

 gl.bindFramebuffer(gl.FRAMEBUFFER,null);
 gl.useProgram(dispP);
 gl.bindTexture(gl.TEXTURE_2D,B);
 gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

 [A,B]=[B,A];
 document.getElementById("f").textContent=frame++;
 requestAnimationFrame(loop);
}
loop(last);
</script>
</body>
</html>
