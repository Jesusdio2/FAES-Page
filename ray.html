<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<title>WebGL2 Path Tracer Acumulativo</title>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden}
canvas{width:100%;height:100%;display:block}
#hud{
  position:fixed;left:10px;top:10px;
  color:#0f0;font:12px monospace;
  background:rgba(0,0,0,.4);
  padding:8px;border:1px solid #0f0
}
</style>
</head>
<body>

<canvas id="c"></canvas>
<div id="hud">
WASD mover · Espacio subir · Shift bajar<br>
Frames acumulados: <span id="f">0</span>
</div>

<script>
const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl2");
if(!gl){ alert("WebGL2 no disponible"); throw 0; }

function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  gl.viewport(0,0,canvas.width,canvas.height);
}
addEventListener("resize",resize);
resize();

/* ================= SHADERS ================= */

const vs = `#version 300 es
layout(location=0) in vec2 p;
out vec2 uv;
void main(){
  uv = p*0.5+0.5;
  gl_Position = vec4(p,0,1);
}`;

const fs = `#version 300 es
precision highp float;
in vec2 uv;
out vec4 frag;

uniform vec3 camPos, camF, camR, camU;
uniform sampler2D history;
uniform int frame;
uniform vec2 res;

float rnd(vec2 p,float s){
  return fract(sin(dot(p+s,vec2(12.9898,78.233)))*43758.5453);
}

bool sphere(vec3 ro,vec3 rd,vec3 c,float r,out float t,out vec3 n){
  vec3 oc=ro-c;
  float b=dot(oc,rd);
  float h=b*b-dot(oc,oc)+r*r;
  if(h<0.)return false;
  t=-b-sqrt(h);
  if(t<0.)return false;
  n=normalize(ro+rd*t-c);
  return true;
}

void main(){
  vec2 p=uv*2.-1.;
  vec3 rd=normalize(camF+p.x*camR+p.y*camU);
  vec3 ro=camPos;

  vec3 col=vec3(0);
  vec3 tp=vec3(1);

  for(int b=0;b<3;b++){
    float t; vec3 n;
    if(sphere(ro,rd,vec3(0,1,0),1.,t,n)){
      ro+=rd*t+n*0.001;
      rd=normalize(n+vec3(
        rnd(uv,float(frame)+float(b)),
        rnd(uv+1.,float(frame)),
        rnd(uv+2.,float(frame))
      )-0.5);
      col+=tp*vec3(0.8,0.3,0.2);
      tp*=0.5;
    }else{
      col+=tp*mix(vec3(0.6,0.7,1),vec3(0.1),rd.y*0.5+0.5);
      break;
    }
  }

  vec3 prev = texture(history,uv).rgb;
  float a = frame==0 ? 1.0 : 1.0/float(frame+1);
  frag = vec4(mix(prev,col,a),1);
}`;

/* =============== PROGRAMA ================= */

function compile(type,src){
  const s=gl.createShader(type);
  gl.shaderSource(s,src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))
    throw gl.getShaderInfoLog(s);
  return s;
}

const prog=gl.createProgram();
gl.attachShader(prog,compile(gl.VERTEX_SHADER,vs));
gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,fs));
gl.linkProgram(prog);
gl.useProgram(prog);

/* =============== QUAD ================= */

const vao=gl.createVertexArray();
gl.bindVertexArray(vao);

const vbo=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,vbo);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([
  -1,-1, 1,-1, -1,1, 1,1
]),gl.STATIC_DRAW);

gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);

/* ============ TEXTURA HISTORIA ============ */

function makeTex(){
  const t=gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D,t);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA32F,
    canvas.width,canvas.height,0,
    gl.RGBA,gl.FLOAT,null);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);
  return t;
}

let texA=makeTex(), texB=makeTex();
const fb=gl.createFramebuffer();

/* =============== CÁMARA ================= */

let camPos=[0,1.2,4];
let yaw=0;
let frame=0;
const keys=new Set();

onkeydown=e=>keys.add(e.code);
onkeyup=e=>keys.delete(e.code);

canvas.onclick=()=>canvas.requestPointerLock();
onmousemove=e=>{
  if(document.pointerLockElement!==canvas)return;
  yaw-=e.movementX*0.002;
  frame=0;
};

function update(dt){
  const sp=dt*3;
  const f=[Math.sin(yaw),0,-Math.cos(yaw)];
  const r=[Math.cos(yaw),0,Math.sin(yaw)];

  if(keys.has("KeyW")){camPos[0]+=f[0]*sp;camPos[2]+=f[2]*sp;frame=0;}
  if(keys.has("KeyS")){camPos[0]-=f[0]*sp;camPos[2]-=f[2]*sp;frame=0;}
  if(keys.has("KeyA")){camPos[0]-=r[0]*sp;camPos[2]-=r[2]*sp;frame=0;}
  if(keys.has("KeyD")){camPos[0]+=r[0]*sp;camPos[2]+=r[2]*sp;frame=0;}
  if(keys.has("Space")){camPos[1]+=sp;frame=0;}
  if(keys.has("ShiftLeft")){camPos[1]-=sp;frame=0;}
}

/* =============== LOOP ================= */

let last=performance.now();
function loop(t){
  const dt=(t-last)/1000; last=t;
  update(dt);

  gl.bindFramebuffer(gl.FRAMEBUFFER,fb);
  gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,
    gl.TEXTURE_2D,texB,0);

  gl.useProgram(prog);
  gl.uniform3fv(gl.getUniformLocation(prog,"camPos"),camPos);
  gl.uniform3fv(gl.getUniformLocation(prog,"camF"),
    [Math.sin(yaw),0,-Math.cos(yaw)]);
  gl.uniform3fv(gl.getUniformLocation(prog,"camR"),
    [Math.cos(yaw),0,Math.sin(yaw)]);
  gl.uniform3fv(gl.getUniformLocation(prog,"camU"),[0,1,0]);
  gl.uniform1i(gl.getUniformLocation(prog,"frame"),frame);
  gl.uniform2f(gl.getUniformLocation(prog,"res"),
    canvas.width,canvas.height);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D,texA);
  gl.uniform1i(gl.getUniformLocation(prog,"history"),0);

  gl.bindVertexArray(vao);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

  gl.bindFramebuffer(gl.READ_FRAMEBUFFER,fb);
  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER,null);
  gl.blitFramebuffer(0,0,canvas.width,canvas.height,
                     0,0,canvas.width,canvas.height,
                     gl.COLOR_BUFFER_BIT,gl.NEAREST);

  [texA,texB]=[texB,texA];
  document.getElementById("f").textContent=frame++;
  requestAnimationFrame(loop);
}
loop(last);
</script>
</body>
</html>
