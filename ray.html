<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>WebGL2 Ray Tracing – Agujero Negro</title>
<style>
html, body { margin:0; overflow:hidden; background:black; }
canvas { width:100vw; height:100vh; display:block; }
#hud {
  position:fixed; top:10px; left:10px;
  color:#0f0; font:12px monospace;
  background:rgba(0,0,0,.4);
  padding:8px; border:1px solid #0f0;
}
</style>
</head>
<body>

<canvas id="gfx"></canvas>
<div id="hud">WASD mover · Espacio subir · Shift bajar · Click para mouse</div>

<script>
/* ================= SHADERS ================= */

const VS = `#version 300 es
layout(location=0) in vec2 aPos;
layout(location=1) in vec2 aUV;
out vec2 vUV;
void main(){
  vUV = aUV;
  gl_Position = vec4(aPos,0.0,1.0);
}`;

const FS = `#version 300 es
precision highp float;

in vec2 vUV;
out vec4 fragColor;

uniform vec3 uCamPos;
uniform vec3 uCamFwd;
uniform vec3 uCamRight;
uniform vec3 uCamUp;
uniform vec2 uResolution;

uniform vec3 uBHPos;
uniform float uBHMass;
uniform float uBHRadius;

void bendRay(inout vec3 ro, inout vec3 rd){
  for(int i=0;i<12;i++){
    vec3 toBH = uBHPos - ro;
    float r = length(toBH);

    if(r < uBHRadius){
      rd = vec3(0.0);
      return;
    }

    float force = uBHMass / (r*r + 0.05);
    rd += normalize(toBH) * force * 0.015;
    rd = normalize(rd);
    ro += rd * 0.15;
  }
}

vec3 accretionDisk(vec3 p){
  vec3 q = p - uBHPos;
  float d = length(q.xz);
  float h = abs(q.y);
  float ring = smoothstep(2.2,1.6,d) * smoothstep(0.15,0.0,h);
  vec3 hot = vec3(1.2,0.9,0.6);
  vec3 warm = vec3(1.0,0.5,0.2);
  return mix(warm,hot,ring) * ring * 3.0;
}

void main(){
  vec2 uv = vUV * 2.0 - 1.0;
  uv.x *= uResolution.x / uResolution.y;

  float fov = radians(60.0);
  vec3 rd = normalize(
    uCamFwd +
    uv.x * uCamRight * tan(fov*0.5) +
    uv.y * uCamUp    * tan(fov*0.5)
  );

  vec3 ro = uCamPos;
  bendRay(ro, rd);

  if(length(rd) < 0.001){
    fragColor = vec4(0.0);
    return;
  }

  float t = 0.5 * (rd.y + 1.0);
  vec3 sky = mix(vec3(0.6,0.7,1.0), vec3(0.02,0.02,0.05), t);

  vec3 col = sky + accretionDisk(ro);
  fragColor = vec4(col,1.0);
}`;

/* ================= WEBGL ================= */

const canvas = document.getElementById("gfx");
const gl = canvas.getContext("webgl2",{antialias:false});
if(!gl) alert("WebGL2 no soportado");

function resize(){
  const dpr = devicePixelRatio||1;
  canvas.width = innerWidth*dpr;
  canvas.height = innerHeight*dpr;
  gl.viewport(0,0,canvas.width,canvas.height);
}
addEventListener("resize",resize);
resize();

function compile(type,src){
  const s = gl.createShader(type);
  gl.shaderSource(s,src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))
    throw gl.getShaderInfoLog(s);
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog,compile(gl.VERTEX_SHADER,VS));
gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,FS));
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog,gl.LINK_STATUS))
  throw gl.getProgramInfoLog(prog);

gl.useProgram(prog);

/* ================= QUAD ================= */

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

gl.bindBuffer(gl.ARRAY_BUFFER,gl.createBuffer());
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([
  -1,-1,0,0,
   1,-1,1,0,
  -1, 1,0,1,
   1, 1,1,1
]),gl.STATIC_DRAW);

gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0,2,gl.FLOAT,false,16,0);
gl.enableVertexAttribArray(1);
gl.vertexAttribPointer(1,2,gl.FLOAT,false,16,8);

/* ================= CAMERA ================= */

let camPos=[0,1.5,6], yaw=0, pitch=0;
const keys={};

onkeydown=e=>keys[e.code]=1;
onkeyup=e=>keys[e.code]=0;

canvas.onclick=()=>canvas.requestPointerLock();
onmousemove=e=>{
  if(document.pointerLockElement!==canvas)return;
  yaw   -= e.movementX*0.002;
  pitch -= e.movementY*0.002;
  pitch=Math.max(-1.4,Math.min(1.4,pitch));
};

function norm(v){
  const l=Math.hypot(...v);
  return v.map(x=>x/l);
}
function cross(a,b){
  return [
    a[1]*b[2]-a[2]*b[1],
    a[2]*b[0]-a[0]*b[2],
    a[0]*b[1]-a[1]*b[0]
  ];
}

/* ================= LOOP ================= */

function loop(){
  const fwd=[
    Math.cos(pitch)*Math.sin(yaw),
    Math.sin(pitch),
    Math.cos(pitch)*Math.cos(yaw)
  ];
  const right=norm(cross(fwd,[0,1,0]));
  const up=cross(right,fwd);

  const sp=0.08;
  if(keys.KeyW) camPos=camPos.map((v,i)=>v+fwd[i]*sp);
  if(keys.KeyS) camPos=camPos.map((v,i)=>v-fwd[i]*sp);
  if(keys.KeyA) camPos=camPos.map((v,i)=>v-right[i]*sp);
  if(keys.KeyD) camPos=camPos.map((v,i)=>v+right[i]*sp);
  if(keys.Space) camPos[1]+=sp;
  if(keys.ShiftLeft) camPos[1]-=sp;

  gl.uniform3fv(gl.getUniformLocation(prog,"uCamPos"),camPos);
  gl.uniform3fv(gl.getUniformLocation(prog,"uCamFwd"),fwd);
  gl.uniform3fv(gl.getUniformLocation(prog,"uCamRight"),right);
  gl.uniform3fv(gl.getUniformLocation(prog,"uCamUp"),up);
  gl.uniform2f(gl.getUniformLocation(prog,"uResolution"),canvas.width,canvas.height);

  gl.uniform3f(gl.getUniformLocation(prog,"uBHPos"),0,1,0);
  gl.uniform1f(gl.getUniformLocation(prog,"uBHMass"),6.0);
  gl.uniform1f(gl.getUniformLocation(prog,"uBHRadius"),0.45);

  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
